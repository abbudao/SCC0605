options{
LOOKAHEAD = 2;
STATIC = false ;
}
PARSER_BEGIN(Jason)
    class Jason{
    public static void main(String[] args)
        throws ParseException, TokenMgrError{
        Jason parser = new Jason(System.in);
        parser.Program();

        }

    }
PARSER_END(Jason)

    SKIP: {<"#" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>}
    SKIP: {" " | "\n" | "\r" | "\r\n" | "\t"}
    TOKEN: {<NUM: (["0"-"9"])+|(["0"-"9"])+ ["."] (["0"-"9"])+>}
    TOKEN: {<PROGRAM: "program">}
    TOKEN: {<BEGIN: "begin">}
    TOKEN: {<END: "end">}
    TOKEN: {<READ: "read">}
    TOKEN: {<WRITE: "write">}
    TOKEN: {<IF: "if">}
    TOKEN: {<SET: "set">}
    TOKEN: {<ENDIF: "endif">}
    TOKEN: {<ELSE: "else">}
    TOKEN: {<DO: "do">}
    TOKEN: {<WHILE: "while">}
    TOKEN: {<ENDWHILE: "endwhile">}
    TOKEN: {<UNTIL: "until">}
    TOKEN: {<ENDUNTIL: "enduntil">}
    TOKEN: {<CALL: "call">}
    TOKEN: {<RECORD: "record">}
    TOKEN: {<TYPES: "types">}
    TOKEN: {<VARIABLES: "variables">}
    TOKEN: {<REAL: "real">}
    TOKEN: {<INT: "integer">}
    TOKEN: {<PROC: "procedure">}
    TOKEN: {<PARAM: "parameters">}
    TOKEN: {<VAR: "var">}
    TOKEN: {<FUNCTION: "function">}
    TOKEN: {<RETURNS: "returns">}
    TOKEN: {<RETURN: "return">}
    TOKEN: {<THEN: "then">}
    TOKEN: {<ARRAY: "array">}
    TOKEN: {<EOL: ";">}
    TOKEN: {<IDENTIFIER: (["a"-"z", "A"-"Z", "_"])+ (<NUM>)*>}
    TOKEN: {<LBR: "[">}
    TOKEN: {<RBR: "]">}
    TOKEN: {<STRING: "\"" (<IDENTIFIER> | <NUM> | " ")+ "\"">}
    TOKEN: {<LP: "(">}
    TOKEN: {<RP: ")">}
    TOKEN: {<SLASH: "\\">}
    TOKEN: {<TIL: "~">}
    TOKEN: {<PLUS: "+">}
    TOKEN: {<LESS: "-">}
    TOKEN: {<TIMES: "*">}
    TOKEN: {<LESSTHAN: "<">}
    TOKEN: {<GREATERTHAN: ">">}
    TOKEN: {<EXCLAMATION: "!">}
    TOKEN: {<POINT: ".">}
    TOKEN: {<ASK: "?">}
    TOKEN: {<GOE: ">=">}
    TOKEN: {<LOE: "<=">}
    TOKEN: {<EQUAL: "=">}
    TOKEN: {<COLON: ":">}
    TOKEN: {<COMA: ",">}
    TOKEN: {<AND: "&">}
    TOKEN: {<DIV: "/">}
    /*Programa e Bloco*/
    void Program():
    {}
    {
    Header() DeclSec() Block()<POINT>

    }

    void Header():
    {}
    {
        <PROGRAM><IDENTIFIER><EOL>
    }
    void Block():
    {}
    {
        <BEGIN>[Statements()]<END>
    }
    /*Declaracoes*/
    void DeclSec():
    {}
    {
        [<TYPES> TypeDecls()|VarDeclSec()|SubProgramDecls()]
    }

    void TypeDecls():
    {}
    {
        (TypeDecl())*
    }
    void TypeDecl():
    {}
    {
        <IDENTIFIER> TypeSpecification()
    }
    void TypeSpecification():
    {}
    {
        ArraySpecification()
        | RecordSpecification()
    }
    void ArraySpecification():
    {}
    {
        <ARRAY> DataType() <LBR> <NUM> <RBR> <EOL>
    }

    void RecordSpecification():
    {}
    {
        <RECORD> VarDecls() <END> <EOL>
    }

    void VarDeclSec():
    {}
    {
        <VARIABLES> VarDecls()
    }

    void VarDecls():
    {}
    {
        VarDecl() ( VarDecl())*
    }

    void VarDecl():
    {}
    {
        DataType() IdList() <EOL>
    }

    void DataType():
    {}
    {
        (<REAL>|<INT>|<IDENTIFIER>|<STRING>)
    }

    void IdList():
    {}
    {
        (<IDENTIFIER> <COMA>)* <IDENTIFIER>
    }

    void SubProgramDecls():
    {}
    {
        SubProgramDecl() (SubProgramDecl())*
    }
    void SubProgramDecl():
    {}
    {
        ProcDecl() | FunctionDecl()
    }
    void ProcDecl():
    {}
    {
        ProcHeader() SubProgramDeclSec() Block() <EOL>
    }

    void ProcHeader():
    {}
    {
        <PROC><IDENTIFIER><EOL>
    }
    void SubProgramDeclSec():
    {}
    {
        [ParamDeclSec()] DeclSec()
    }
    void ParamDeclSec():
    {}
    {
        <PARAM> ParamDecls()
    }

    void ParamDecls():
    {}
    {
        ParamDecl() (ParamDecls())*
    }

    void ParamDecl():
    {}
    {
        [<VAR>] DataType() <IDENTIFIER> <EOL>
    }

    void FunctionDecl():
    {}
    {
        FunctionHeader() SubProgramDeclSec() FunctionBlock() <EOL>
    }

    void FunctionHeader():
    {}
    {
        <FUNCTION> <IDENTIFIER> <RETURNS> DataType() <EOL>
    }

    void FunctionBlock():
    {}
    {
        <BEGIN> [Statements()] ReturnStatement() <END>
    }
    /* Comandos */
    void Statements():
    {}
    {
        Statement() (<EOL>Statement())*
    }

    void Statement():
    {}
    {
        (<READ> | <WRITE>) Variable()
        | <SET> Variable() <EQUAL> Expression()
        | <IF> Condition_Exp() <THEN> Statements() ElseClause()
        | <WHILE> Condition_Exp() <DO> [Statements()] <ENDWHILE>
        | <UNTIL> Condition_Exp() <DO> [Statements()] <ENDUNTIL>
        | <CALL> <IDENTIFIER> [ArgList()]
        | Condition_Exp()
    }
    void Condition_Exp():
    {}
    {
        Condition()[<ASK> [Condition_Exp()] <COLON> [Condition_Exp()] ]
    }
    void ElseClause():
    {}
    {
        [<ELSE>] [Statements()] <ENDIF>
    }
    void ReturnStatement():
    {}
    {
        <EOL> <RETURN><LP>Condition_Exp()<RP>
    }

    void ArgList():
    {}
    {
        <LP> [Arguments()] <RP>
    }

    void Arguments():
    {}
    {
        (Condition_Exp() <COMA>)* Condition_Exp()
    }
    void Condition():
    {}
    {
        CompoundCondition() (<SLASH>CompoundCondition())*
    }

    void CompoundCondition():
    {}
    {
        SimpleCondition() (<AND> SimpleCondition())*
    }
    void SimpleCondition():
    {}
    {
        Expression() (RelOp() Expression())*
    }
    void Expression():
    {}
    {
        Term() (AddOp() Term())*
    }
    void Term():
    {}
    {
        Unary() (MultOp() Unary())*
    }

    /*Expressoes*/
    void Unary():
    {}
    {
        (<PLUS>|<LESS>) Unary()
        | Factor()
    }
    void Factor():
    {}
    {
        [<TIL>] (Variable()
        | <NUM>
        | <STRING>
        | <LP> Condition_Exp() <RP>
        | <IDENTIFIER> ArgList() )
    }
    void Variable():
    {}
    {
        <IDENTIFIER> [<LBR> Expression() <RBR>]
            (<POINT> <IDENTIFIER> [<LBR>Expression()<RBR>])*
    }
    void RelOp():
    {}
    {
        <EQUAL>
        | <EXCLAMATION>
        | <GREATERTHAN>
        | <LESSTHAN>
        | <LOE>
        | <GOE>
    }
    void AddOp():
    {}
    {
        <PLUS>
        | <LESS>
    }
    void MultOp():
    {}
    {
        <TIMES> | <DIV>
    }
