options{
LOOKAHEAD = 1;
STATIC = false ;
}
PARSER_BEGIN(Adder)
    class Adder{
    public static void main(String[] args)
        throws ParseException, TokenMgrError{
        Adder parser = new Adder(System.in);
        parser.Start();

        }

    }
PARSER_END(Adder)

    SKIP: {" "}
    SKIP: {"\n" | "\r" | "\r\n"}
    TOKEN: {<PLUS: "+">}
    TOKEN: {<NUM: (["0"-"9"])+>}
    TOKEN: {<PROGRAM: "program">}
    TOKEN: {<BEGIN: "begin">}
    TOKEN: {<END: "end">}
    TOKEN: {<EOL: ";">} 
    TOKEN: {<IDENTIFIER: (["a"-"z", "A"-"Z"])+>}
    TOKEN: {<ARRAY: "array">}
    TOKEN: {<LBR: "[">}
    TOKEN: {<RBR: "]">}
    TOKEN: {<RECORD: "record">}
    TOKEN: {<TYPES: "types">}
    TOKEN: {<VARIABLES: "variables">}
    TOKEN: {<REAL: "real">}
    TOKEN: {<INT: "integer">}
    TOKEN: {<STRING: "\"" (<IDENTIFIER> | <NUMBERS> | " ")+ "\"">}
    void Program():
    {}
    {
    Header()[DeclSec()]Block()<EOF>

    }

    void Header():
    {}
    {
        <PROGRAM><IDENTIFIER><EOL>
    }
    void Block():
    {}
    {
        <BEGIN>Statements()<END>
    }

    void DeclSec():
    {}
    {
        <TYPES> TypeDecls() [(VarDeclSec() SubProgramDecls() | SubProgramDecls() | VarDeclSec())]
        | [VarDeclSec()]SubProgramDecls()
    }

    void TypeDecls():
    {}
    {
        (TypeDecl())*
    }
    void TypeDecl():
    {}
    {
        <IDENTIFIER> TypeSpecification()
    }
    void TypeSpecification():
    {}
    {
        ArraySpecification()
        | RecordSpecification()
    }
    void ArraySpecification():
    {}
    {
        <ARRAY> DataType() <LBR> <NUM> <RBR> <EOL>
    }

    void RecordSpecification():
    {}
    {
        <RECORD> VarDecls() <END> <EOL>
    }

    void VarDeclSec():
    {}
    {
        <VARIABLES> VarDecls()
    }

    void VarDecls():
    {}
    {
        (VarDecls())* VarDecl()
    }

    void VarDecl():
    {}
    {
        DataType() IdList() <EOL>
    }
    void DataType():
    {}
    {
        <REAL>|<INT>|<IDENTIFIER>|<STRING>
    }
    void IdList():
    {}
    {
        
    }
    /*
    hProgrami ::= hHeader i [hDeclSeci] hBlocki ‘.’ (1)
hHeader i ::= ‘program’ identifier ‘;’ (2)
hBlocki ::= ‘begin’ [hStatementsi] ‘end’ (3)
16
hDeclSeci ::= types hTypeDeclsi ( hVarDeclSecihSubProgramDeclsi (4)
| hSubProgramDeclsi (5)
| hVarDeclSeci (6)
| λ) (7)
| [hVarDeclSeci] hSubProgramDeclsi (8)
hTypeDeclsi ::= {hTypeDecli} (9)
hTypeDecli ::= identifier hTypeSpecificationi (10)
hTypeSpecificationi ::= hArraySpecificationi (11)
| hRecordSpecificationi (12)
hArraySpecificationi ::= array hDataTypei ‘[’numericliteral‘]’ ‘;’ (13)
hRecordSpecificationi ::= record hVarDeclsi end; (14)
hVarDeclSeci ::= variables hVarDeclsi (15)
hVarDeclsi ::= {hVarDeclsi} hVarDecli (16)
hVarDecli ::= hDataTypei hIdListi‘;’ (17)
hDataTypei ::= real (18)
| integer (19)
| identifier (20)
| string (21)
hIdListi ::= {identifier ‘,’} identifier (22)
hSubProgramDeclsi ::= [hSubProgramDeclsi]hSubProgramDecli (23)
hSubProgramDecli ::= hProcDecli (24)
| hFunctionDecli (25)
hProcDecli ::= hProcHeader i hSubProgramDeclSeci hBlocki‘;’ (26)
hProcHeader i ::= procedure identifier ‘;’ (27)
hSubProgramDeclSeci ::= [hParamDeclSeci] hDeclSeci (28)
Grupo de regras 5 Declara¸c˜oes (EBNF)
hParamDeclSeci ::= parameters hParamDeclsi (29)
hParamDeclsi ::= [hParamDeclsi]hParamDecli (30)
hParamDecli ::= [var]hDataTypei identifier ‘;’ (31)
17
hFunctionDecli ::= hFunctionHeader i hSubProgramDeclSeci (32)
hFunctionBlocki ‘;’
hFunctionHeader i ::= function returns hDatatypei ‘;’ (33)
hFunctionBlocki ::= begin [hStatementsi] hReturnStatementi end (34)
hStatementsi ::= { hStatementsi ‘;’} hStatementi (35)
hStatementi ::= (read | write) hVariablei (36)
| set hVariablei = hExpressioni (37)
| if hConditioni then [hStatementsi] hElseClausei (38)
| while hConditioni do [hStatementsi] endwhile (39)
| until hConditioni do [hStatementsi] enduntil (40)
| call identifier [hArgListi] (41)
| hTernaryi (42)
hTernaryi ::= hConditioni?[hStatementsi]:[hStatementsi] (43)
hElseClausei ::= [else] [hStatementsi] endif (44)
hReturnStatementi ::= ‘;’ return ‘(’ hConditioni ‘)’ (45)
hArgListi ::= ‘(’ hArgumentsi ‘)’ (46)
hArgumentsi ::= {hConditioni ‘,’} hConditioni (47)
hConditioni ::= {hCompoundConditioni \ } hCompoundConditioni (48)
hCompoundConditioni ::= {hSimpleConditioni (49)
’&’} hSimpleConditioni
hSimpleConditioni ::= {hExpressioni hRelOpi} hExpressioni (50)
hExpressioni ::= {hTermi hAddOpi} hTermi (51)
hTermi ::= hUnaryi {hMultOpi hFactor i} (52)
Grupo de regras 6 Express˜oes (EBNF)
hUnaryi ::= {(‘+’ | ‘-’)} hFactor i (53)
hFactor i ::= [ ˜] (hVariablei (54)
| numericliteral (55)
| stringliteral (56)
| ‘(’hConditioni‘)’ (57)
| identifier hArglisti (58)
| hTernaryi) (59)
18
hVariablei ::= identifier [‘[’ hExpressioni ‘]’] (60)
{.identifier [‘[’ hExpressioni ‘]’]}
hRelOpi ::= ‘==’ (61)
| ‘!’ (62)
| ‘>’ (63)
| ‘<’ (64)
| ‘<=’ (65)
| ‘>=’ (66)
hAddOpi ::= ‘+’ (67)
| ‘-’ (68)
hMultOpi ::= ‘*’

    */